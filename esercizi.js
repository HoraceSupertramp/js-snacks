
/***
 * Una semplice griglia
 * 
 * Scrivere il corpo di una funzione che, dato un numero, stampa in console una stringa che
 * contenga una griglia quadrata di cancelletti (#) di lato lungo quanto il numero dato.
 * Esempio: grid(3) stampa a video la stringa:
 *    ###
 *    ###
 *    ###
 * Nota: il carattere "a capo" si scrive "\n". Esempio: console.log("\n") stampa una riga
 * vuota che va subito a capo.
 */

function grid(number) {

}

/***
 * Media Aritmetica
 * 
 * Calcolo della media di un array. Scrivere il corpo di una funzione che, dato un array di numeri,
 * restituisce un numero che rappresenti la media dei numeri che l'array contiene.
 */

function average(numbersArray) {

}

/***
 * Math.Pow
 * 
 * Calcolo della potenza di un numero. Scrivere il corpo di una funzione che, dati due numeri BASE e ESPONENTE,
 * calcoli e restituisca il valore di BASE elevato alla ESPONENTE.
 * 
 * Nota: NON si può usare Math.pow() nel corpo della nostra implementazione.
 */

function pow(base, exponent) {

}

/***
 * Giusto quel poco di matematica
 * 
 * Calcolo del fattoriale di un numero. Scrivere il corpo di una funzione che, dato un numero,
 * restituisce il fattoriale di quel numero. Il fattoriale di un numero si calcola così:
 * si prende quel numero e lo si moltiplica per tutti i suoi predecessori.
 * Esempio:
 *    factorial(7) === 7 * 6 * 5 * 4 * 3 * 2 * 1
 *    factorial(4) === 4 * 3 * 2 * 1
 */

function factorial(number) {

}

/***
 * Push ma non su Github
 * 
 * Implementazione della push() sugli array: scrivere il corpo di una funzione che, dato un array A
 * ed un nuovo elemento E, inserisca E in fondo all'array A e restituisca la nuova lunghezza dell'array.
 *
 * Nota: NON si può usare la vera push() degli array nel corpo della nostra implementazione.
 */

function push(array, newElement) {
    
}

/***
 * Pop quando non è Push
 * 
 * Implementazione della pop() sugli array: scrivere il corpo di una funzione che, dato un array A
 * rimuova da esso l'elemento in fondo e restituisca l'elemento rimosso.
 *
 * Nota: NON si può usare la vera pop() degli array nel corpo della nostra implementazione.
 */

function pop(array) {
    
}

/***
 * Unshi(f)t 
 * 
 * Implementazione della unshift() sugli array: scrivere il corpo di una funzione che, dato un array A
 *    ed un nuovo elemento E, inserisca E in cima all'array A e restituisca la nuova lunghezza dell'array.
 *
 * Nota: NON si può usare la vera unshift() degli array nel corpo della nostra implementazione.
 */

function unshift(array, newElement) {
    
}

/***
 * Ma era Shift o era Pop?
 * 
 * Implementazione della shift() sugli array: scrivere il corpo di una funzione che, dato un array A,
 * rimuove l'elemento in testa ad A e restituisce l'elemento rimosso.
 *
 * Nota: NON si può usare la vera shift() degli array nel corpo della nostra implementazione.
 */

function shift(array) {
    
}

/***
 * Include, ma non era PHP
 * 
 * Implementazione della includes() sugli array: scrivere il corpo di una funzione che, dato un array A,
 * e un valore B, restituisce true se A contiene B, restituisce false altrimenti.
 *
 * Nota: NON si può usare la vera includes() degli array nel corpo della nostra implementazione.
 */

function shift(array) {
    
}

/***
 * Join the Party
 * 
 * Implementazione simile alla join() sugli array: scrivere il corpo di una funzione che, dato un array A
 * di stringhe, restituisce la stringa ottenuta come concatenazione dei membri di A.
 *
 * Nota: NON si può usare la vera join() degli array nel corpo della nostra implementazione.
 */

function join(array) {
    
}

/***
 * Banane? Split
 * 
 * Implementazione simile alla split() sugli array: scrivere il corpo di una funzione che, data una stringa A,
 * restituisce un array contenente i singoli caratteri di A, uno dopo l'altro.
 *
 * Nota: NON si può usare la vera split() degli array nel corpo della nostra implementazione.
 */

function split(word) {
    
}

/***
 * Con Cat o Con Dog?
 * 
 * Implementazione della concat() sugli array: scrivere il corpo di una funzione che, dati due array A e B,
 * restituisce un nuovo array contenente gli elementi di A seguiti da quelli di B.
 *
 * Nota: NON si può usare la vera concat() degli array nel corpo della nostra implementazione.
 */

function concat(array1, array2) {
    
}

/***
 * Finders Keepers
 * 
 * Implementazione della find() sugli array: scrivere il corpo di una funzione che, dato un array A
 * ed un predicato(*) P, restituisce il primo elemento dell'array che verifica P, se esso esiste.
 * Altrimenti restituisce null.
 * Ovvero: scrivere il corpo della funzione find() sapendo che riceve come parametri un array e una
 * callback. La callback ricevuta come argomento, quando invocata con uno degli elementi dell'array
 * come unico argomento, restituise true se esso è l'elemento cercato, false altrimenti. Se l'elemento
 * cercato viene trovato, lo si restituisce. Altrimenti si restituisce null.
 *
 * Nota: NON si può usare la vera find() degli array nel corpo della nostra implementazione.
 */

function find(array, callback) {
    
}

/***
 * Esrever
 * 
 * Scrivere il corpo di una funzione che, dato un array, restituisca un nuovo array contenente i suoi stessi
 * elementi ma in ordine inverso.
 *
 * Nota: NON si può usare la vera reverse() degli array nel corpo della nostra implementazione.
 */

function reverse(array) {
    
}

/***
 * Con Ripetizioni o Senza?
 * 
 * Verifica dell'unicità degli elementi di un array. Scrivere il corpo di una funzione che, dato un array,
 * verifica se l'array contiene dei valori tutti distinti (restituisce true), oppure se contiene doppioni
 * (restituisce false). 
 */

function unique(array) {

}

/***
 * Forìc
 * 
 * Implementazione della forEach() sugli array: scrivere il corpo di una funzione che, dato un array A
 * ed una funzione, chiama quella funzione su ciascuno degli elementi di A, uno alla volta.
 *
 * Nota: NON si può usare la vera forEach() degli array nel corpo della nostra implementazione.
 */

function forEach(array, callback) {
    
}

/***
 * La Map del Tesoro
 * 
 * Implementazione della map() sugli array: scrivere il corpo di una funzione che, dato un array A
 * ed una funzione di conversione C, restituisce un nuovo array B contenente indice per indice gli elementi
 * di A convertiti tramite la funzione di conversione.
 * 
 * Ovvero: scrivere il corpo della funzione map() sapendo che riceve come parametri un array e una
 * callback(*) e che deve restituire un nuovo array contenente tanti elementi quanti quelli nell'array dato.
 * La callback(*) ricevuta come argomento, quando invocata con uno degli elementi dell'array come unico argomento,
 * converte quell'elemento restituendo il risultato della conversione. Questo risultato deve essere inserito
 * in un nuovo array, allo stesso indice dell'elemento che è stato convertito in partenza. Il nuovo array così prodotto
 * viene infine restituito.
 *
 * Nota: NON si può usare la vera map() degli array nel corpo della nostra implementazione.
 */

function map(array, callback) {
    
}

/***
 * La Map del Tesoro di Strings
 * 
 * Scrivere il corpo di una funzione che riceve come argomento un array di numeri A e che restituisce
 * un nuovo array B contenente, indice per indice le stringhe in A convertite in numero.
 * 
 * Nota: Nel corpo della nostra implementazione NON si può usare la vera map() degli array, ma possiamo utilizzare
 * quella definita da noi poco sopra.
 */

function mapStringsToNumbers(stringsArray) {
    
}

/***
 * (No) Filter
 * 
 * Implementazione della filter() sugli array: scrivere il corpo di una funzione che, dato un array A
 * ed un predicato(*) P, restituisce un nuovo array B contenente il sottoinsieme di elementi di A che
 * verificano P.
 * 
 * Ovvero: scrivere il corpo della funzione filter() sapendo che riceve come parametri un array e una
 * callback e che deve restituire un nuovo array contenente solo alcuni tra gli elementi dell'array
 * originale. La callback ricevuta come argomento, quando invocata con uno degli elementi dell'array
 * come unico argomento, restituise false se tale elemento deve essere "filtrato via", true se invece
 * l'elemento deve essere riportato in un nuovo array. Il nuovo array così prodotto
 * viene infine restituito.
 *
 * Nota: NON si può usare la vera filter() degli array nel corpo della nostra implementazione.
 */

function filter(array, callback) {
    
}

/***
 * (No Odd) Filter
 * 
 * Scrivere il corpo di una funzione che, dato un array A, restituisce un nuovo array B
 * contenente solo i numeri pari contenuti in A.
 *
 * Nota: Nel corpo della nostra implementazione NON si può usare la vera filter() degli array, ma possiamo utilizzare
 * quella definita da noi poco sopra.
 */

function filterEven(numbersArray) {
    
}

/***
 * Che la Sort ti sorrida
 * 
 * Ordinare un array: scrivere il corpo di una funzione che, dato un array di numeri, restituisca lo stesso
 * array passato come argomento ma dopo aver ordinato i suoi elementi in modo crescente.
 *
 * Nota: NON si può usare la vera sort() degli array nel corpo della nostra implementazione.
 */

function sort(numbersArray) {
    
}

/***
 * Every (-breathyoutake)
 * 
 * Implementazione della every() sugli array: scrivere il corpo di una funzione che, dato un array A ed un
 * Predicato(*) B, restituisce true solo se, invocando il predicato con ogni elemento di A come argomento,
 * questo restituisce sempre true.
 *
 * Nota: Se l'array A è vuoto, every() restituisce sempre true a prescindere da B.
 * Nota: NON si può usare la vera every() degli array nel corpo della nostra implementazione.
 */

function every(array, predicate) {
    
}

/***
 * Some (-whereovertheraimbow)
 * 
 * Implementazione della some() sugli array: scrivere il corpo di una funzione che, dato un array A ed un
 * Predicato(*) B, restituisce true solo se, invocando il predicato con ogni elemento di A come argomento,
 * questo restituisce almeno un true.
 *
 * Nota: Se l'array A è vuoto, some() restituisce sempre false a prescindere da B.
 * Nota: NON si può usare la vera some() degli array nel corpo della nostra implementazione.
 */

function some(array, predicate) {
    
}

/***
 * Hover Crafted
 * 
 * Reimplementazione dell':hover CSS in JavaScript. Scrivere una funzione che, dato un selettore, recupera dal DOM
 * tutti gli elementi corrispondenti a quel selettore e si mette in ascolto di alcuni eventi su ognuno di essi in modo che:
 *  - quando il mouse entra in uno degli elementi, si aggiunge su di esso la classe CSS "hover"
 *  - quando il mouse esce da uno degli elementi, si rimuove da esso la classe CSS "hover"
 */

function hover(selector) {
    
}

/***
 * Modal da Sfliata
 * 
 * Scrivere una funzione che riceva come parametri i componenti HTML di una finestra modale e ne implementi il
 * funzionamento. modalify() riceve come argomento:
 * - container: l'elemento HTML corrispondente al contenitore della finestra modale. Quando ad esso viene data la classe
 *              'open' il modale viene rivelato nel CSS e piazzato fixed davanti a tutto nella pagina. Quando la classe
 *              'open' non è presente su di esso, il modale non è visibile.
 * - opener: l'elemento HTML (probabilmente un <button>) che fa da pulsante di apertura della finestra modale. 
 * - closer: l'elemento HTML (probabilmente un <button> dentro al modale) che fa da pulsante di chiusura della finestra
 *           modale.
 * Cosa deve accadere dopo l'esecuzione di modalify():
 * Ogni volta che avviene il click su sull'opener, la finestra modale deve diventare visibile.
 * Ogni volta che avviene il click su sul closer, la finestra modale deve diventare invisibile.
 */

function modalify(container, opener, closer) {
    
}

/***
 * Che poi alla fine il Carosello lo puoi scrive' in Tre Righe
 * 
 * Scrivere una funzione che riceva come parametri gli elementi HTML di un carosello e ne implementi il
 * funzionamento. carousellify() riceve come argomento:
 * - container: l'elemento HTML corrispondente al contenitore del carosello.
 * - slides: la lista degli elementi HTML (figli del container) che fanno da slides del carosello. Quando ad uno di questi
 *           elementi viene data la classe 'active', esso diventa la slide attiva (visibile) nel carosello.
 * Quando la funzione carousellify() viene chiamata, la prima slide del carosello deve diventare quella attiva.
 * Cosa deve accadere dopo l'esecuzione di carousellify():
 * Le slides devono diventare attive una dopo l'altra con un intervallo di 4 secondi tra l'una e l'altra.
 * Non possono esserci due slides visibili contemporaneamente.
 * Ogni volta che il mouse entra nel container, lo sliding automatico deve essere messo in pausa
 * Ogni volta che il mouse esce dal container, lo sliding automatico viene ripreso.
 */

function carousellify(container, slides) {
    
}

/***
 * Accordion in Sol Maggiore
 * 
 * Scrivere una funzione che riceva come parametri i componenti HTML di un accordion e ne implementi il
 * funzionamento. accordionify() riceve come argomento:
 * - drawers: la lista degli elementi HTML che fanno da cassetti dell'accordion. Quando ad uno di questi
 *           elementi viene data la classe 'open', il cassetto viene graficamente reso nel CSS come aperto.
 * Cosa deve accadere dopo l'esecuzione di accordionify():
 * Quando avviene il click su uno dei drawers, se esso è aperto, viene chiuso. Altrimenti, viene aperto e se
 * e è già presente un altro drawer aperto, quest'ultimo viene chiuso.
 */

function accordionify(drawers) {
    
}

/***
 * Timer proprio quello da Cucina
 * 
 * Scrivere una funzione che riceve come parametri i componenti HTML di un timer e ne implementa il
 * funzionamento. timerify() riceve come argomento:
 * - secondElement: l'elemento HTML in cui rappresentare l'anno della data odierna
 * - minuteElement: l'elemento HTML in cui rappresentare l'anno della data odierna
 * - hourElement: l'elemento HTML in cui rappresentare l'anno della data odierna
 * - dayElement: l'elemento HTML in cui rappresentare il giorno della data odierna
 * - monthElement: l'elemento HTML in cui rappresentare il mese della data odierna
 * - yearElement: l'elemento HTML in cui rappresentare l'anno della data odierna
 * Cosa deve accadere dopo l'esecuzione di timerify():
 * Ogni secondo, il contenuto HTML degli elementi passati come argomento deve essere correttamente aggiornato secondo
 * la data.
 */

function timerify(
    secondElement,
    minuteElement,
    hourElement,
    dayElement,
    monthElement,
    yearElement,
) {
    
}
